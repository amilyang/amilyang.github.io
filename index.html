<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>amilyang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="amilyang的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="amilyang">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="amilyang">
<meta property="og:description" content="amilyang的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="amilyang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="amilyang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">amilyang</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">经验在于总结</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ionic入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/24/ionic%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2020-05-24T10:32:22.000Z" itemprop="datePublished">2020-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/24/ionic%E5%85%A5%E9%97%A8/">ionic入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/24/ionic%E5%85%A5%E9%97%A8/" data-id="ckakxnbxw0000yywjgyzkbaxj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-一维数组JSON树结构的转换" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/06/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84JSON%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84%E8%BD%AC%E6%8D%A2/" class="article-date">
  <time datetime="2020-05-06T14:23:15.000Z" itemprop="datePublished">2020-05-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/06/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84JSON%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84%E8%BD%AC%E6%8D%A2/">一维数组JSON树结构的转换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="场景数据和思路"><a href="#场景数据和思路" class="headerlink" title="场景数据和思路"></a>场景数据和思路</h2><p>五一之前有个面试当中问到了处理JSON格式的数据问题，我平时处理的数据当中很少有需要前端转换的，不过这次面试官提出了一个这样的问题，他描述了多级导航在后台数据库中存储的方式，如样例数据：</p>
<pre><code>var jsonData = [{&quot;id&quot;:&quot;1&quot;,&quot;pid&quot;:&quot;0&quot;,&quot;name&quot;:&quot;家用电器&quot;}, {&quot;id&quot;:&quot;4&quot;,&quot;pid&quot;:&quot;1&quot;,&quot;name&quot;:&quot;大家电&quot;}, {&quot;id&quot;:&quot;5&quot;,&quot;pid&quot;:&quot;1&quot;,&quot;name&quot;:&quot;生活电器&quot;}, {&quot;id&quot;:&quot;2&quot;,&quot;pid&quot;:&quot;0&quot;,&quot;name&quot;:&quot;服饰&quot;}, {&quot;id&quot;:&quot;3&quot;,&quot;pid&quot;:&quot;0&quot;,&quot;name&quot;:&quot;化妆&quot;}, {&quot;id&quot;:&quot;7&quot;,&quot;pid&quot;:&quot;4&quot;,&quot;name&quot;:&quot;空调&quot;}, {&quot;id&quot;:&quot;8&quot;,&quot;pid&quot;:&quot;4&quot;,&quot;name&quot;:&quot;冰箱&quot;}, {&quot;id&quot;:&quot;9&quot;,&quot;pid&quot;:&quot;4&quot;,&quot;name&quot;:&quot;洗衣机&quot;}, {&quot;id&quot;:&quot;10&quot;,&quot;pid&quot;:&quot;4&quot;,&quot;name&quot;:&quot;热水器&quot;}, {&quot;id&quot;:&quot;11&quot;,&quot;pid&quot;:&quot;3&quot;,&quot;name&quot;:&quot;面部护理&quot;}, {&quot;id&quot;:&quot;12&quot;,&quot;pid&quot;:&quot;3&quot;,&quot;name&quot;:&quot;口腔护理&quot;}, {&quot;id&quot;:&quot;13&quot;,&quot;pid&quot;:&quot;2&quot;,&quot;name&quot;:&quot;男装&quot;}, {&quot;id&quot;:&quot;14&quot;,&quot;pid&quot;:&quot;2&quot;,&quot;name&quot;:&quot;女装&quot;}, {&quot;id&quot;:&quot;15&quot;,&quot;pid&quot;:&quot;7&quot;,&quot;name&quot;:&quot;海尔空调&quot;}, {&quot;id&quot;:&quot;16&quot;,&quot;pid&quot;:&quot;7&quot;,&quot;name&quot;:&quot;美的空调&quot;}, {&quot;id&quot;:&quot;19&quot;,&quot;pid&quot;:&quot;5&quot;,&quot;name&quot;:&quot;加湿器&quot;}, {&quot;id&quot;:&quot;20&quot;,&quot;pid&quot;:&quot;5&quot;,&quot;name&quot;:&quot;电熨斗&quot;}];</code></pre><p>在此之前我见到的数据结构都是处理好的，当然这样道题考察到我的盲区了，所以赶紧补补课</p>
<p>方法思路使用js数组自带的filter()方法；数据格式要求，父子节点通过，Id，ParentId进行关联。默认父结节id为0</p>
<h2 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h2><pre><code>function creatTreeData(list){
  var clonelist = JSON.parse(JSON.stringify(list));
  var result =clonelist.filter(function(father){
    var childlist = clonelist.filter(function(child){
      return father.id == child.pid;
    });
    if(childlist.length&gt;0){
      father.children=childlist;
    }
    return father.pid ==0;
  });
  return result;
}

console.log(JSON.stringify(creatTreeData(jsonData)).toString())

[{&quot;id&quot;:&quot;1&quot;,&quot;pid&quot;:&quot;0&quot;,&quot;name&quot;:&quot;家用电器&quot;,&quot;children&quot;:[{&quot;id&quot;:&quot;4&quot;,&quot;pid&quot;:&quot;1&quot;,&quot;name&quot;:&quot;大家电&quot;,&quot;children&quot;:[{&quot;id&quot;:&quot;7&quot;,&quot;pid&quot;:&quot;4&quot;,&quot;name&quot;:&quot;空调&quot;,&quot;children&quot;:[{&quot;id&quot;:&quot;15&quot;,&quot;pid&quot;:&quot;7&quot;,&quot;name&quot;:&quot;海尔空调&quot;},{&quot;id&quot;:&quot;16&quot;,&quot;pid&quot;:&quot;7&quot;,&quot;name&quot;:&quot;美的空调&quot;}]},{&quot;id&quot;:&quot;8&quot;,&quot;pid&quot;:&quot;4&quot;,&quot;name&quot;:&quot;冰箱&quot;},{&quot;id&quot;:&quot;9&quot;,&quot;pid&quot;:&quot;4&quot;,&quot;name&quot;:&quot;洗衣机&quot;},{&quot;id&quot;:&quot;10&quot;,&quot;pid&quot;:&quot;4&quot;,&quot;name&quot;:&quot;热水器&quot;}]},{&quot;id&quot;:&quot;5&quot;,&quot;pid&quot;:&quot;1&quot;,&quot;name&quot;:&quot;生活电器&quot;,&quot;children&quot;:[{&quot;id&quot;:&quot;19&quot;,&quot;pid&quot;:&quot;5&quot;,&quot;name&quot;:&quot;加湿器&quot;},{&quot;id&quot;:&quot;20&quot;,&quot;pid&quot;:&quot;5&quot;,&quot;name&quot;:&quot;电熨斗&quot;}]}]},{&quot;id&quot;:&quot;2&quot;,&quot;pid&quot;:&quot;0&quot;,&quot;name&quot;:&quot;服饰&quot;,&quot;children&quot;:[{&quot;id&quot;:&quot;13&quot;,&quot;pid&quot;:&quot;2&quot;,&quot;name&quot;:&quot;男装&quot;},{&quot;id&quot;:&quot;14&quot;,&quot;pid&quot;:&quot;2&quot;,&quot;name&quot;:&quot;女装&quot;}]},{&quot;id&quot;:&quot;3&quot;,&quot;pid&quot;:&quot;0&quot;,&quot;name&quot;:&quot;化妆&quot;,&quot;children&quot;:[{&quot;id&quot;:&quot;11&quot;,&quot;pid&quot;:&quot;3&quot;,&quot;name&quot;:&quot;面部护理&quot;},{&quot;id&quot;:&quot;12&quot;,&quot;pid&quot;:&quot;3&quot;,&quot;name&quot;:&quot;口腔护理&quot;}]}]</code></pre><h2 id="方法的封装"><a href="#方法的封装" class="headerlink" title="方法的封装"></a>方法的封装</h2><pre><code>/**
* @param {Array} list 
* @param {String} id 
* @param {string} pid 
* @param {string} children 
*/

function treeData(list, id, pid, children){
  var cloneData = JSON.parse(JSON.stringify(list))
  return cloneData.filter(father =&gt; {
    var childlist = cloneData.filter(child =&gt; {
      return father[id] = child[pid]
    })
    if(childlist.length &gt; 0) {
      father[children] = childlist
    }
    return father[pid] == 0 
  })
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/06/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84JSON%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84%E8%BD%AC%E6%8D%A2/" data-id="ck9vgswlg0000ozwjg48t74gf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Object-create-null" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/29/Object-create-null/" class="article-date">
  <time datetime="2020-04-29T13:56:20.000Z" itemprop="datePublished">2020-04-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/29/Object-create-null/">Object.create(null)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Vue和Vuex的源码中，作者都是用了Object.create(null)来初始化一个新对象。为什么不用更简洁的{}呢？</p>
<h2 id="Object-create-定义"><a href="#Object-create-定义" class="headerlink" title="Object.create() 定义"></a>Object.create() 定义</h2><p>在MDN上的定义如下：</p>
<pre><code>Object.create(proto,[propertiesObject])    </code></pre><ul>
<li>proto: 新创建对象的原型对象   </li>
<li>propertiesObject： 可选。如果没有指定为undefined，则是要添加到新创建对象的 <strong>不可枚举</strong> （默认）属性(即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。</li>
<li>返回值：在指定原型对象上添加新属性后的对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var ob &#x3D; &#123;a：1&#125;;</span><br><span class="line">console.log(ob)</span><br></pre></td></tr></table></figure>

<p>在控制台中可以看到新创建的对象继承了Object自身的方法，如hasOwnProperty、toString等，在新对象上可以直接使用。</p>
<p>再看看使用Object.create()创建对象</p>
<pre><code>var ob = Object.create(null,{
    a:{
        writable:true,
        configurable:true,
        value:&apos;1&apos;
    }
})
console.log(ob)</code></pre><p>可以看到，新创建的对象除了自身属性a之外，原型链上没有任何属性，也就是没有继承Object的任何东西，此时如果我们调用o.toString()会报Uncaught TypeError的错误。<br>第一个参数使用了null。也就是说将null设置成了新创建对象的原型，自然就不会有原型链上的属性。</p>
<p>var o = Object.create({},{<br>    a:{<br>        writable:true,<br>        configurable:true,<br>        value:’1’<br>    }<br>})<br>console.log(o)</p>
<p>将null改为{}，结果是怎样的？<br>在chrome控制台中，我们可以看到，这样创建的对象和使用{}创建对象已经很相近了，但是还是有一点区别：多了一层proto嵌套。</p>
<p>我们最后再来改一下：</p>
<pre><code>var o = Object.create(Object.prototype,{
    a:{
        writable:true,
        configurable:true,
        value:&apos;1&apos;
    }
})
console.log(o)</code></pre><p>这次就和使用{}创建的对象一模一样了。至此，我相信大家已经对两者的区别十分清楚了。</p>
<h2 id="Object-create-null-的使用场景"><a href="#Object-create-null-的使用场景" class="headerlink" title="Object.create(null)的使用场景"></a>Object.create(null)的使用场景</h2><p>使用create创建的对象，没有任何属性，显示No properties，我们可以把它当作一个非常纯净的map来使用，我们可以自己定义hasOwnProperty、toString方法，不管是有意还是不小心，我们完全不必担心会将原型链上的同名方法覆盖掉。</p>
<pre><code>//Demo1:
var a= {...省略很多属性和方法...};
//如果想要检查a是否存在一个名为toString的属性，你必须像下面这样进行检查：
if(Object.prototype.hasOwnProperty.call(a,&apos;toString&apos;)){
    ...
}
//为什么不能直接用a.hasOwnProperty(&apos;toString&apos;)?因为你可能给a添加了一个自定义的hasOwnProperty
//你无法使用下面这种方式来进行判断,因为原型上的toString方法是存在的：
if(a.toString){}

//Demo2:
var a=Object.create(null)
//你可以直接使用下面这种方式判断，因为存在的属性，都将定义在a上面，除非手动指定原型：
if(a.toString){}</code></pre><p>另一个使用create(null)的理由是，在我们使用for..in循环的时候会遍历对象原型链上的属性，使用create(null)就不必再对属性进行检查了，当然，我们也可以直接使用Object.keys[]。</p>
<p>总结一下：</p>
<p>你需要一个非常干净且高度可定制的对象当作数据字典的时候；<br>想节省hasOwnProperty带来的一丢丢性能损失并且可以偷懒少些一点代码的时候<br>用Object.create(null)吧！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/29/Object-create-null/" data-id="ck9vgqhyj0001otwj3tvwax94" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-EventEmitter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/29/EventEmitter/" class="article-date">
  <time datetime="2020-04-29T04:34:09.000Z" itemprop="datePublished">2020-04-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/29/EventEmitter/">EventEmitter</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>面试题中通常会问到父子组件传值的问题， 父组件自定义事件（on），子组件监听自定义事件（emit），都会进一步问是否可以手动实现一个EvntEmmiter</p>
<p>刷到这儿了，就来了解一下</p>
<pre><code>class Event {
  constructor() {
    this.events = Object.create(null);
  }
  on(name, fn) {
    if (!this.events[name]) {
      this.events[name] = []
    }
    this.events[name].push(fn);
    return this;
  }
  emit(name, ...args) {
    if (!this.events[name]) {
        return this;
    }
    const fns = this.events[name]
    fns.forEach(fn =&gt; fn.call(this, ...args))
    return this;
  }
  off(name,fn) {
    if (!this.events[name]) {
        return this;
    }
    if (!fn) {
      this.events[name] = null
      return this
    }
    const index = this.events[name].indexOf(fn);
    this.events[name].splice(index, 1);
    return this;
  }
  once(name,fn) {
    const only = () =&gt; {
      fn.apply(this, arguments);
      this.off(name, only);
    };
    this.on(name, only);
    return this;
  }
}</code></pre><p>刷到的代码是这样的，刚看的时候，我看没去看 this， 箭头函数这部分内容，或者说之前都是仅限于使用，在明白了this的绑定规则 和 箭头函数的使用后，又琢磨这段代码中的this指的是什么，为什么要返回this，是和jquery中的链式操作一样的吗？ 带着这些疑问，我进行了代码测试，并且自己也跟着写了一遍。整理如下：</p>
<ol>
<li><p>这里return this确实是和jquery中的return this一样，返回了<br>Event对象，所以这里可以使用链式操作。</p>
</li>
<li><p>这里使用Object.create(null)来赋值， 而不是{},  也是我好奇的一部分，其他大牛给出的答案是这种情况下我们需要一个非常干净且高度可以定制的对象当作数据字典。具体原因我会再整理一篇关于Object.create()的用法</p>
</li>
<li><p>在我学到 this 和 箭头函数时，里面有介绍过，说箭头函数没有自己的this， 它使用的是外层代码块的this ，另外 箭头函数中是没有arguments 这个参数的，可以用rest参数代替， 而上面的代码中在箭头函数中使用的arguments是沿着作用域链向上查找的父作用域中的aruments，这里的arguments的值是{0: myevent, 1: Funtion}, 这里取到的 arguments并不是我们想要用的参数列表，所以应该在箭头函数中使用rest参数，这样就能获取到fn当中的参数了，这里的a ，b，正确代码如下</p>
</li>
<li><p>这里也多次使用到了call和apply来显式的绑定this，并传入参数</p>
<p>class Event {<br> constructor() {<br>   this.events = Object.create(null);<br> }<br> on(name, fn) {<br>   if (!this.events[name]) {</p>
<pre><code>this.events[name] = []</code></pre><p>   }<br>   this.events[name].push(fn);<br>   return this;<br> }<br> emit(name, …args) {<br>   if (!this.events[name]) {</p>
<pre><code>return this;</code></pre><p>   }<br>   const fns = this.events[name]<br>   fns.forEach(fn =&gt; fn.call(this, …args))<br>   return this;<br> }<br> off(name,fn) {<br>   if (!this.events[name]) {</p>
<pre><code>return this;</code></pre><p>   }<br>   if (!fn) {</p>
<pre><code>this.events[name] = null
return this</code></pre><p>   }<br>   const index = this.events[name].indexOf(fn);<br>   this.events[name].splice(index, 1);<br>   return this;<br> }<br> once(name,fn) {<br>   const only = (…args) =&gt; { // a， b</p>
<pre><code>fn.apply(this, args);
this.off(name, only);</code></pre><p>   };<br>   this.on(name, only);<br>   return this;<br> }<br>}</p>
<p>var instance = new Event()<br>instance.once(‘myevent’, function (a, b){<br> console.log(a, b)<br> return a + b<br>}).emit(‘myevent’,1,2)</p>
</li>
</ol>
<p>在Vue中不同组件之间的通讯。有一种解决方法叫 <strong>Event Bus</strong>，这其实就是发布订阅模式的实现，非常简单好用。</p>
<pre><code>// bus.js
export default new Vue();

//使用$on监听
import Bus from &apos;../bus.js&apos;

export default{
  created() {
    Bus.$on(&apos;fulfilled&apos;, text =&gt; {
      this.status = &apos;fulfilled&apos;
    })
  }
}

// 使用$emit触发事件
fetch(&apos;/data.json&apos;).then((res) =&gt; {
  return res.json
}).then(() =&gt; {
  Bus.$emit(&apos;fulfilled&apos;, &apos;已成功&apos;)
}).catch(() =&gt; {
  Bus.$emit(&apos;resolved&apos;, &quot;出错&quot;)
})</code></pre><p>Vue事件相关接口：<br>on， emit， once， off</p>
<p>使用Event Bus 进行跨组件消息传递很棒，但是，当事件非常多的时候，Event Bus上的事件就会难以维护，这与使用全局变量是一样的，变量能局部的，就尽量不放到全局，同样Event bus上的事件也是越少越好。</p>
<h2 id="发布订阅模式与观察者模式"><a href="#发布订阅模式与观察者模式" class="headerlink" title="发布订阅模式与观察者模式"></a>发布订阅模式与观察者模式</h2><p>直到现在对于发布订阅模式与观察者模式，还是傻傻分不清。。。。。</p>
<p>观察者模式英文名：Observer<br>发布订阅者模式英文名： Pub-Sub</p>
<p>《Learning JavaScript Design Patterns》中的解释</p>
<p>“While the Observer pattern is useful to be aware of, quite often in the Javascript world, we’ll find it commonly implemented using a variation known as the Publish/Subscribe pattern”</p>
<p>虽然Oberser模式非常有用，但是在Javascript的世界中，它更多的以一种被称为发布订阅者模式的变种来实现</p>
<p>两者的区别在于，发布/订阅模式在观察者模式的基础上，在目标和观察者之间增加了一个调度中心</p>
<p><img src="/.com//observer-pub-sub.jpg" alt="observer-pub-sub"><br><strong>观察者模式</strong> 是由具体目标调度，比如当事件触发，Subject就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的。</p>
<p><strong>发布/订阅模式</strong>  由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/29/EventEmitter/" data-id="ck9vgqhya0000otwjfvdkcshb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-this" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/28/this/" class="article-date">
  <time datetime="2020-04-28T03:21:29.000Z" itemprop="datePublished">2020-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript-%E5%8E%9F%E7%94%9F/">javascript 原生</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/this/">this</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="this-是什么？"><a href="#this-是什么？" class="headerlink" title="this 是什么？"></a>this 是什么？</h2><p>this是什么？ 首先记住this不是指自身！ this就是一个指针， 指向调用函数的对象</p>
<h2 id="this有哪些绑定规则？"><a href="#this有哪些绑定规则？" class="headerlink" title="this有哪些绑定规则？"></a>this有哪些绑定规则？</h2><ul>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>硬绑定</li>
<li>new 绑定</li>
</ul>
<h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>默认绑定，在不能应用其他绑定规则时使用默认规则。通常是独立函数调用。</p>
<pre><code>function sauHi(){
    console.log(&quot;Hello&quot;, this.name)
}
var name =&apos;ddssd&apos;
sayHi()</code></pre><p>在调用Hi（）时，应用了默认绑定，this指向全局对象（非严格模式下），严格模式下指向undefined， undefined上没有this 对象。会抛出错误。</p>
<p>上面的代码，如果在浏览器环境中运行，那么结果是 Hello ddssd</p>
<p>但如果在node环境中运行，结果就是Hello， undefined，这是因为node中name并不是挂在全局对象上的</p>
<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>函数的调用在某个对象上触发的，即调用位置上存在上下文对象，典型的形式为 XXX.fun()。我们来看一段代码：</p>
<pre><code>function sayHi(){
  console.log(&apos;Hello,&apos;, this.name);
}
var person = {
  name: &apos;YvetteLau&apos;,
  sayHi: sayHi
}
var name = &apos;Wiliam&apos;;
person.sayHi();</code></pre><p>sayHi函数声明在外部，严格来说并不属于person，但是在调用sayHi时，调用位置会使用person的上下文来引用函数，隐式绑定会把函数调用中的this，（即此例sayH函数中的thisi）绑定到这个上下文对象（即此例中的person）</p>
<p>需要注意的是： 对象属性链中只有最后一层会影响到调用位置</p>
<pre><code>function sayHi(){
    console.log(&apos;Hello,&apos;, this.name);
}
var person2 = {
    name: &apos;Christina&apos;,
    sayHi: sayHi
}
var person1 = {
    name: &apos;YvetteLau&apos;,
    friend: person2
}
person1.friend.sayHi();</code></pre><p>结果是：Hello, Christina.</p>
<p>因为只有最后一层会确定this指向的是什么，不管有多少层，在判断this的时候，我们只关注最后一层，即此处的friend</p>
<p>隐式绑定有一个大陷阱，绑定很容易丢失（或者说容易给我们造成误导，我们以为this指向的是什么，但是实际上并非如此）</p>
<pre><code>function sayHi(){
    console.log(&apos;Hello,&apos;, this.name);
}
var person = {
    name: &apos;YvetteLau&apos;,
    sayHi: sayHi
}
var name = &apos;Wiliam&apos;;
var Hi = person.sayHi;
Hi();</code></pre><p>结果是: Hello,Wiliam.</p>
<p>这是为什么呢，Hi直接指向了sayHi的引用，在调用的时候，跟person没有半毛钱的关系，针对此类问题，我建议大家只需牢牢记住这个格式:XXX.fn(); fn()前如果什么都没有，那么肯定不是隐式绑定。</p>
<p>除了上面这种丢失之外，隐式绑定的丢失是发生在回调函数中(事件回调也是其中一种)，我们来看下面一个例子:</p>
<h2 id="绑定优先级"><a href="#绑定优先级" class="headerlink" title="绑定优先级"></a>绑定优先级</h2><p>我们知道了this有四种绑定规则，但是如果同时应用了多种规则，怎么办？<br>显然，我们需要了解哪一种绑定方式的优先级更高，这四种绑定的优先级为：</p>
<p>new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<h2 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h2><p>凡事都有例外，this规则也是这样</p>
<p>如果我们将null或者undefined作为this的绑定对象传入call、apply或者是bind，这些值在调用的时候会被忽略，实际应用的是默认绑定规则</p>
<pre><code>var foo = {
  name: &apos;Selina&apos;
}
var name = &apos;Chirs&apos;;
function bar() {
  console.log(this.name);
}
bar.call(null); //Chirs </code></pre><p>在浏览器模式下输出了Chirs，因为这时实际应用的是默认绑定规则</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数是ES6中新增的，它和普通函数有一些区别，箭头函数没有自己的this，它的this继承于外层代码库中的this。 箭头函数在使用时，需要注意一下几点：</p>
<ol>
<li><p>函数体内的this，继承的是外层代码块的this</p>
</li>
<li><p>不可以当作构造函数，也就是说，不可以使用new 命令，否则会抛出一个错误</p>
</li>
<li><p>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。</p>
</li>
<li><p>不可以使用yield， 因此箭头函数不能用做Generator函数</p>
</li>
<li><p>箭头函数，没有自己的this，所以不能用call，apply，bind这些方法去改变this指向</p>
<pre><code>var obj = {
  hi: function() {
    console.log(this)
    return () =&gt; {
      console.log(this)
    }
  },
  sayHi: function(){
    return function(){
      console.log(this)
      return () =&gt; {
        console.log(this)
      }
    }
  },
  say: () =&gt; {
    console.log(this)
  }
}

let hi = obj.hi() //输出obj对象
hi() //输出obj对象
let sayHi = obj.sayHi() 
let fun1 = sayHi() //输出window
fun1() //输出window
obj.say() //输出window</code></pre></li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="如何准确判断this指向的是什么？"><a href="#如何准确判断this指向的是什么？" class="headerlink" title="如何准确判断this指向的是什么？"></a>如何准确判断this指向的是什么？</h2><ol>
<li>函数是否咋new中调用（new绑定），如果是，那么this绑定的是新创建的对下岗</li>
<li>函数是否通过call、apply调用，或者使用bind（即硬绑定），如果是，那么this绑定的就是指定的对象</li>
<li>函数是否在某个上下文对象中调用（隐式绑定） ，如果是的话，thisa绑定的就是那个上下文对象，一般是obj.foo()</li>
<li>如果以上都不是，那么使用默认绑定，如果在严格模式下，则绑定到undefined，否则绑定到全局对象</li>
<li>如果把null或者undefined做为this的绑定对象传入call，apply， bind，这些值在调用时会被忽略，实际应用的是默认绑定规则</li>
<li>如果是箭头函数，箭头函数的this继承的是外层代码块的this。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/28/this/" data-id="ck9vgtzaz0000p3wj2ll9eqne" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-css" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/27/css/" class="article-date">
  <time datetime="2020-04-27T10:19:51.000Z" itemprop="datePublished">2020-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/css/">css</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/css/">css</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="标准盒模型和怪异盒模型"><a href="#标准盒模型和怪异盒模型" class="headerlink" title="标准盒模型和怪异盒模型"></a>标准盒模型和怪异盒模型</h2><ul>
<li><p>标准盒模型中 width 指的是内容区域content的宽度； height指的是内容区域content的高度。<br>标准盒模型下盒子的大小 = content + padding + border + margin<br><img src="/.com//standard.jpg" alt="标准盒模型"></p>
</li>
<li><p>怪异盒模型中的 <strong>width</strong> 指的是内容、边框、内边距（content + border + padding）；<strong>height</strong> 指的是内容、边框、内边距的高度.<br>怪异盒模型下盒子的大小 = width（content + padding + border） + margin<br><img src="/.com//ie.jpg" alt="IE盒模型"></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/27/css/" data-id="ck9icgt7o00000pwj03rz57nl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-防抖和节流" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/" class="article-date">
  <time datetime="2020-04-26T10:34:37.000Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/">防抖和节流</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/" data-id="ck9gx1l1c0000eswj3m5m7xmw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深拷贝和浅拷贝" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time datetime="2020-04-26T10:06:10.000Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript-%E5%8E%9F%E7%94%9F/">javascript 原生</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">深拷贝和浅拷贝</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>浅拷贝是指只复制第一层对象，但是当对象的属性是引用类型时，实质复制的事其引用，当引用指向的值发生改变也会跟着改变</p>
<p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响到另一个对象。</p>
<p>实现一个深拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj) &#123; &#x2F;&#x2F;递归拷贝</span><br><span class="line">  debugger</span><br><span class="line">  if(obj &#x3D;&#x3D;&#x3D; null) return null</span><br><span class="line">  if(obj instanceof RegExp) return new RegExp(obj)</span><br><span class="line">  if(obj instanceof Date) return new Date(obj)</span><br><span class="line">  if(typeof obj !&#x3D;&#x3D; &#39;object&#39;)&#123;</span><br><span class="line">    &#x2F;&#x2F; 如果不是复杂数据类型，直接返回</span><br><span class="line">    return obj</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 如果obj是数组，那么 obj.constructor 是 [Function: Array]</span><br><span class="line">   * 如果obj是对象，那么 obj.constructor 是 [Function: Object]</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">   let t &#x3D; obj.constructor();</span><br><span class="line"></span><br><span class="line">   for(let key in obj)&#123;</span><br><span class="line">     &#x2F;&#x2F;如果 obj[key] 是复杂数据类型，递归</span><br><span class="line">     t[key] &#x3D; deepClone(obj[key])</span><br><span class="line">   &#125;</span><br><span class="line">   return t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: 9</span><br><span class="line">  &#125;,</span><br><span class="line">  d: [</span><br><span class="line">    1,2,3,4</span><br><span class="line">  ],</span><br><span class="line">  e:&#123;</span><br><span class="line">    f:&#123;</span><br><span class="line">      s:1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var clone &#x3D;  deepClone(a)</span><br><span class="line">console.log(clone)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" data-id="ck9gwkse60000dqwj5whv14do" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-函数柯里化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/25/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/" class="article-date">
  <time datetime="2020-04-25T02:17:36.000Z" itemprop="datePublished">2020-04-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript-%E5%8E%9F%E7%94%9F/">javascript 原生</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/25/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/">函数柯里化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是函数柯里化？"><a href="#什么是函数柯里化？" class="headerlink" title="什么是函数柯里化？"></a>什么是函数柯里化？</h2><p>柯里化（Currying），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<p>通过下面这个例子来理解一下概念</p>
<pre><code>function sum(a,b,c){
  return a+b+c
}
function curryingSum(a){
  return function(b){
    return function(c) {
      return a + b +c
    }
  }
}
console.log(sum(1,2,3))
console.log(curryingSum(1)(2)(3))</code></pre><p>实际上就是sum函数的a，b，c三个参数变成了先用一个函数接受a，然后返回一个函数去处理b参数，现在思路应该理的差不多了，只是传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数</p>
<p>问题是我们费那么大劲封装一层，到底有什么用处呢？ </p>
<h2 id="柯里化有哪些好处-？"><a href="#柯里化有哪些好处-？" class="headerlink" title="柯里化有哪些好处 ？"></a>柯里化有哪些好处 ？</h2><h3 id="1-参数复用"><a href="#1-参数复用" class="headerlink" title="1. 参数复用"></a>1. 参数复用</h3><pre><code>// 正常的正则验证字符串 reg.test(txt)
// 函数封装后
function check(reg, txt){
  return reg.test(txt)
}

console.log(check(/\d+/g,&apos;test&apos;)) //false 
console.log(check(/[a-z]+/g, &apos;test&apos;))    //true

// 看看我们Currying后

function CurryingCheck(reg){
  return function(txt) {
    return reg.test(txt)
  }
}

var hasNumber = CurryingCheck(/\d+/g)
var hasLetter = CurryingCheck(/[a-z]+/g)

console.log(hasNumber(&apos;test1&apos;)) // true
console.log(hasNumber(&apos;tests&apos;)) // false
console.log(hasLetter(&apos;12233&apos;)) // false</code></pre><p>上面的实例是一个正则的检验，正常来说直接点用check函数就可以了，但是如果我们有很多地方都要检验是否有数字，其实就是需要将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便</p>
<h3 id="2-提前确认"><a href="#2-提前确认" class="headerlink" title="2.提前确认"></a>2.提前确认</h3><pre><code>var on = function(element, event, handler){
  if(document.addEventListener){
    if(element&amp;&amp;event&amp;handler){
      element.addEventListener(event, handler, false)
    }
  } else {
    if(element&amp;&amp;event&amp;handler){
      element.attachEvent(&apos;on&apos; + event, handler)
    }
  }
}
var on = (function() {
  if(document.addEventListener){
    return function(element,event,handler){
      if(element&amp;&amp;event&amp;&amp;handler){
        element.addEventListener(event,handler,false)
      }
    }
  } else {
    return function(element, event, handler){
      if(element&amp;&amp;event&amp;handler){
        element.attachEvent(&apos;on&apos; + event, handler)
      }
    }
  }
})()

// 换一种写法可能比较好理解一点，上面就是把isSupport这个参数先确定下来了

var on = function(isSupport, element,event,handler){
  isSupport = isSupport || document.addEventListener
  if(isSupport){
    return element.addEventListener(event,handler,false)
  } else {
    return  element.attachEvent(&apos;on&apos; + event, handler)
  }
}</code></pre><p>我们在做项目的过程中，封装一些dom操作可以说再常见不过，上面第一种写法比较常见，但是我们看看第二种写法，它相对第一种写法就是自执行函数返回一个新函数，这样其实就是提前确定了会走到哪一个方法，避免每次都进行判断    </p>
<h3 id="3-延迟运行"><a href="#3-延迟运行" class="headerlink" title="3.延迟运行"></a>3.延迟运行</h3><pre><code>Function.prototype._bind = function(context){
  var fn = this
  var args = Array.prototype.slice.call(arguments)
  return function() {
    fn.apply(context, args)
  }
}

var obj = {
  name: &apos;yml&apos;,
  say: function() {
    console.log(this.name)
  }
}

var test = {
  name: &apos;test&apos;,
}

var testSay = obj.say._bind(test)

testSay() // test</code></pre><p>像我们js中经常使用的bind。 实现机制就是Currying</p>
<p>说了这几点好处之后，我们发现还有个问题，难道每次使用Currying都要对底层函数去做修改？</p>
<h2 id="通用的封装方法"><a href="#通用的封装方法" class="headerlink" title="通用的封装方法"></a>通用的封装方法</h2><pre><code>// 初步封装
var currying = function(fn) {
  // args获取第一个方法内的全部参数
  var args = Array.prototype.slice.call(arguments,1)
  return function() {
    //将后面方法理的全部参数和args进行合并
    var newArgs = args.concat(Array.prototype.slice.call(arguments))
        // 把合并后的参数通过apply作为fn的参数并执行
        return fn.apply(this, newArgs)
  }
}

function sum(a, b){
  return a + b
}

let sumFn = currying(sum,10)
console.log(sumFn(20)) // 30</code></pre><p>这边首先是初步封装，通过闭包把初步参数给保存下来，然后通过获取剩下的arguments进行拼接，最后执行需要currying的函数。</p>
<p>但是这个初步封装还是有缺陷的，这样返回的话其实只能多扩展一个参数，currying(a)(b)(c)这样的，恐怕就不行了（不支持多参数调用），一般这种情况都会想到使用递归再封装一层。</p>
<pre><code>//支持多参数传递
function currying(fn, args = []) {
  return function() {
    let rest = [...args, ...arguments];
    //如果参数个数小于最初的fn.length, 则递归调用，继续收集参数
    if(rest.length &lt; fn.length){
      return currying.call(this, fn, rest)
    } 
    // 多参数收集完毕，则执行fn
    return fn.apply(this, rest)
  }
}</code></pre><p>在初步的基础上，加了递归调用，只要参数个数小于最初的fn.length，就会继续执行递归<br>此处补充一个我个人的一个盲区：<br>fn.length的作用： 显示函数参数的期望参数个数</p>
<pre><code>function fn1(){
  console.log(&apos;fn1&apos;);
}
function fn2(a,b){
 console.log(a+b);
}
function fn3(a,b,c,d){
  fn2.call(this,a,b)+fn2.call(this,c,d);
}

console.log(fn1.length) //0
console.log(fn2.length) //2
console.log(fn3.length) //4</code></pre><h2 id="柯里化的性能"><a href="#柯里化的性能" class="headerlink" title="柯里化的性能"></a>柯里化的性能</h2><ul>
<li>存取aruments对象通常要比存取命名参数要慢一些</li>
<li>一些老版本的浏览器在arguments.length的实现上是相当慢的</li>
<li>使用fn.apply(…) 和fn.call(…)通常比直接调用fn(…)稍微慢点</li>
<li>创建大量嵌套作用域和闭包函数会点来花销，无论是在内存上还是速度上</li>
</ul>
<p>其实在大部分应用，主要的性能瓶颈是在操作DOM节点上，这js的性能损耗基本上可以忽略不计，所以currying是可以直接放心使用的</p>
<h2 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h2><pre><code>function add() {
  debugger
  // 第一次执行时，定义一个数组专门用来存储所有的参数
  var _args = Array.prototype.slice.call(arguments);

  // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
  var _adder = function() {
      _args.push(...arguments);
      return _adder;
  };

  // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
  _adder.toString = function () {
      return _args.reduce(function (a, b) {
          return a + b;
      });
  }
  return _adder;
}

console.log(add(1)(2)(3).toString())               // 6
add(1, 2, 3)(4)             // 10
add(1)(2)(3)(4)(5)          // 15
add(2, 6)(1)                // 9</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/25/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/" data-id="ck9gd2k8r0000quwje2kdg5un" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-有趣的冷知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/24/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2020-04-24T03:34:30.000Z" itemprop="datePublished">2020-04-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%86%B7%E7%9F%A5%E8%AF%86/">冷知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/24/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/">有趣的冷知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>试题一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方式1: 一个构造函数嘛，里面有个全局变量getName 指向一个匿名函数（小心闭包）  </span><br><span class="line">function Foo() &#123;  </span><br><span class="line">  getName &#x3D; function () &#123;   </span><br><span class="line">      console.log (1);   </span><br><span class="line">  &#125;;  </span><br><span class="line">  console.log(&#39;this is&#39;+this)  </span><br><span class="line">  return this;  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F; 方式2：构造函数的一个属性getName 指向一个匿名函数  </span><br><span class="line">Foo.getName &#x3D; function () &#123;   </span><br><span class="line">  console.log (2);   </span><br><span class="line">&#125;;  </span><br><span class="line">&#x2F;&#x2F; 方式3: 构造函数的原型上有一个getName方法</span><br><span class="line">Foo.prototype.getName &#x3D; function () &#123;   </span><br><span class="line">  console.log(&#39;baidu&#39; &amp;&amp; &#39;google&#39;);   </span><br><span class="line">&#125;;  </span><br><span class="line">&#x2F;&#x2F;定义一个变量，指针指向匿名函数</span><br><span class="line">var getName &#x3D; function () &#123;   </span><br><span class="line">  console.log (4);  </span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;声明一个getName有名方法</span><br><span class="line">function getName() &#123;   </span><br><span class="line">  console.log (5);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 请写出一下的输出结果  </span><br><span class="line">Foo.getName();   &#x2F;&#x2F; 2</span><br><span class="line">getName();  &#x2F;&#x2F; 4 </span><br><span class="line">Foo().getName();  &#x2F;&#x2F; this is[object Window]  1  </span><br><span class="line">getName();  &#x2F;&#x2F;1  </span><br><span class="line">new Foo.getName();  &#x2F;&#x2F;2  </span><br><span class="line">&#x2F;&#x2F; this is[object Object]</span><br><span class="line">new Foo().getName();  &#x2F;&#x2F;google  </span><br><span class="line">&#x2F;&#x2F; this is[object Object]</span><br><span class="line">new new Foo().getName(); &#x2F;&#x2F;google</span><br></pre></td></tr></table></figure>
<p>这道题设计的知识点很多，我的基础知识有些欠缺，所以在这儿补补基础，这其中涉及到了逻辑运算符、运算符的优先级、声明变量和声明函数的提升优先级、原型继承、闭包、覆盖等知识点</p>
<ul>
<li>执行语句第一行：Foo.getName()<br>这句调用的是方式2</li>
<li>执行语句第二行：getName();<br>如果单看这条执行语句，一般会有个全局声明的函数，即方式  5，但放在这么复杂的上下文环境中，肯定没那么简单了，因为还有个方式4 来捣乱，这里考察了一个知识点，当定义的变量和生命的函数重名了怎么办？ 答案是：他们都会进行预解析，函数声明提前于变量声明，到那时最终会被负变量覆盖，所以这里使用的是方式4，输出结果 “4”</li>
<li>执行语句第三行： Foo().getName()<br>这句有个执行顺序，先执行方式1 的Foo(),结果是“this” 并指向window，并产生了一个全局getName（window.getName）指针指向一个匿名函数，然后再执行“this.getName()”, 其实就是执行刚刚造出来的那个全局getName指向的匿名函数，所以输出“1”。</li>
<li>执行语句第四行：getName()<pre><code>此句执行的是方式1执行出来的那个全局变量getName 指针指向的匿名函数，有人问为啥不执行方式4？俺想说方式4已经被覆盖了！所以结果为 “1”.</code></pre></li>
<li>执行语句第五行：new Foo.getName()<pre><code>首先还是先看运算符优先级吧，我自个看完的结果是【new Foo() &gt;  Foo() &gt; new Foo】，先运算方式2的Foo.getName() 结果为“2”，再new一个Foo实例对象。</code></pre></li>
<li>执行语句第六行：new Foo().getName()<pre><code>先执行 new Foo(), 结果产生一个新的实例对象，并且继承了Foo()这个构造函数中的getName方法，所以再执行方式3函数块，而接着有涉及到另一个知识点：逻辑运算符运算， 对于 “&amp;&amp;”来说，如果前者为真，那么就去执行后者，否则只执行前者； 对于“||”来说，如果前者为真，只执行前者，后者不必执行，否则还得执行后者。因此结果为 “google”。</code></pre><blockquote>
<blockquote>
<p>执行语句第七行：new new Foo().getName()</p>
<pre><code>先执行new Foo(),变成了 new Foo的实例对象.getName(), 然后再执行 Foo的实例对象.getName(),又回到了方式3函数块，结果为“google”，最后执行new Foo的实例对象。</code></pre></blockquote>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var y &#x3D; 10;</span><br><span class="line">if (!(x in window)) &#123;</span><br><span class="line">   var x &#x3D; 10;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">   ++y;</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(x); &#x2F;&#x2F;undefined</span><br><span class="line"> console.log(y); &#x2F;&#x2F;11</span><br></pre></td></tr></table></figure>

<p>代码分析： 如果你和我一样不了解这个知识点，你肯定也不明白为什么会是这个结果。<br>2行代码中的x没有声明，所以应该undefined， 即undefined in window，你可能和我一样认为应该是false，再取反，应该是true， It’s terrible! 完全不是我们所想的那样。原因是“在ES3的定义中，undefined是window的一个全局变量”</p>
<p><img src="/.com//data.png" alt="data"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/24/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/" data-id="ck9dnhxyi0000afwjex5wdq80" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript-%E5%8E%9F%E7%94%9F/">javascript 原生</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%86%B7%E7%9F%A5%E8%AF%86/">冷知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/">原理探究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/">编程面试题</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/24/ionic%E5%85%A5%E9%97%A8/">ionic入门</a>
          </li>
        
          <li>
            <a href="/2020/05/06/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84JSON%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84%E8%BD%AC%E6%8D%A2/">一维数组JSON树结构的转换</a>
          </li>
        
          <li>
            <a href="/2020/04/29/Object-create-null/">Object.create(null)</a>
          </li>
        
          <li>
            <a href="/2020/04/29/EventEmitter/">EventEmitter</a>
          </li>
        
          <li>
            <a href="/2020/04/28/this/">this</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 amilyang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>